<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KP Gradient Generator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f8f9fa;
            color: #333;
            line-height: 1.5;
            height: 100vh;
            overflow: hidden;
        }

        .app-container {
            display: flex;
            height: 100vh;
        }

        /* Main gradient display area */
        .gradient-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: white;
            position: relative;
            min-width: 450px;
        }

        .gradient-display {
            width: 400px;
            height: 533px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
            border: 1px solid #e5e7eb;
            position: relative;
            overflow: hidden;
        }

        .time-badge {
            position: absolute;
            top: 16px;
            left: 16px;
            background: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.875rem;
            backdrop-filter: blur(4px);
        }

        .gradient-info-bar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 16px 24px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            border: 1px solid #e5e7eb;
            display: none;
            max-width: 90%;
        }

        .color-palette-mini {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
        }

        .color-swatch-mini {
            width: 30px;
            height: 30px;
            border-radius: 6px;
            border: 1px solid #e5e7eb;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .color-swatch-mini:hover {
            transform: scale(1.1);
        }

        .css-preview {
            font-family: monospace;
            font-size: 0.75rem;
            color: #6b7280;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 300px;
        }

        /* Sidebar controls */
        .controls-sidebar {
            width: 380px;
            background: white;
            border-left: 1px solid #e5e7eb;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow-y: auto;
        }

        .sidebar-header {
            padding: 20px;
            border-bottom: 1px solid #e5e7eb;
            background: #f8f9fa;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .sidebar-header h1 {
            font-size: 1.5rem;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 16px;
        }

        .mode-selector {
            display: flex;
            gap: 8px;
        }

        .mode-btn {
            flex: 1;
            padding: 8px 12px;
            border: 2px solid #e5e7eb;
            border-radius: 6px;
            background: white;
            color: #374151;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 500;
            font-size: 0.875rem;
            text-align: center;
        }

        .mode-btn.active {
            background: #3b82f6;
            color: white;
            border-color: #3b82f6;
        }

        .mode-btn:hover:not(.active) {
            background: #f9fafb;
            border-color: #d1d5db;
        }

        .sidebar-content {
            flex: 1;
            padding: 20px;
        }

        .mode-content {
            display: none;
        }

        .mode-content.active {
            display: block;
        }

        /* Control sections */
        .control-section {
            background: #f8fafc;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
            border: 1px solid #e2e8f0;
        }

        .control-section h3 {
            font-size: 1rem;
            font-weight: 500;
            color: #374151;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .control-group {
            margin-bottom: 12px;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        .control-group label {
            display: block;
            font-size: 0.875rem;
            font-weight: 500;
            color: #374151;
            margin-bottom: 4px;
        }

        .control-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        input[type="range"] {
            flex: 1;
            height: 4px;
            background: #e5e7eb;
            border-radius: 2px;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #6366f1;
            border-radius: 50%;
            cursor: pointer;
        }

        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #6366f1;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .value-display {
            font-size: 0.75rem;
            color: #6b7280;
            font-weight: 500;
            min-width: 35px;
            text-align: right;
        }

        select, input[type="time"], input[type="number"] {
            width: 100%;
            padding: 6px 8px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            font-size: 0.875rem;
            background: white;
        }

        button {
            width: 100%;
            padding: 8px 12px;
            border: none;
            border-radius: 6px;
            background: #374151;
            color: white;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.875rem;
        }

        button:hover {
            background: #111827;
        }

        .toggle-switch {
            position: relative;
            width: 40px;
            height: 20px;
            background: #d1d5db;
            border-radius: 10px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .toggle-switch.active {
            background: #3b82f6;
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 16px;
            height: 16px;
            background: white;
            border-radius: 50%;
            transition: transform 0.2s;
        }

        .toggle-switch.active::after {
            transform: translateX(20px);
        }

        .toggle-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
        }

        .toggle-row label {
            margin-bottom: 0;
            font-size: 0.875rem;
        }

        /* Image upload styles */
        .upload-area {
            border: 2px dashed #d1d5db;
            border-radius: 8px;
            padding: 24px 16px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: #fafbfc;
            margin-bottom: 16px;
        }

        .upload-area:hover {
            border-color: #9ca3af;
            background: #f3f4f6;
        }

        .upload-area.dragover {
            border-color: #3b82f6;
            background: #eff6ff;
        }

        #fileInput {
            display: none;
        }

        .upload-text {
            font-size: 0.875rem;
            margin-bottom: 4px;
            color: #4b5563;
            font-weight: 500;
        }

        .upload-hint {
            color: #9ca3af;
            font-size: 0.75rem;
        }

        .image-preview {
            max-width: 100%;
            max-height: 100px;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            margin-bottom: 12px;
        }

        /* Preset buttons */
        .presets-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            margin-top: 8px;
        }

        .preset-btn {
            padding: 6px 8px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            background: white;
            color: #374151;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.75rem;
            font-weight: 500;
        }

        .preset-btn:hover {
            background: #f3f4f6;
        }

        .preset-btn.active {
            background: #3b82f6;
            color: white;
            border-color: #3b82f6;
        }

        /* Enhanced presets */
        .enhanced-presets {
            display: flex;
            gap: 4px;
            margin-top: 8px;
        }

        .enhanced-preset-btn {
            flex: 1;
            padding: 4px 8px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            background: white;
            color: #374151;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.75rem;
        }

        .enhanced-preset-btn:hover {
            background: #f3f4f6;
        }

        .enhanced-preset-btn.active {
            background: #3b82f6;
            color: white;
            border-color: #3b82f6;
        }

        /* Animation controls */
        .animation-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 12px;
        }

        .animation-buttons {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }

        .play-btn, .stop-btn {
            flex: 1;
            background: #3b82f6;
            font-size: 0.75rem;
            padding: 6px 8px;
        }

        .stop-btn {
            background: #ef4444;
            display: none;
        }

        .animation-progress {
            width: 100%;
            height: 6px;
            background: #e5e7eb;
            border-radius: 3px;
            overflow: hidden;
            margin-top: 8px;
        }

        .animation-progress-bar {
            height: 100%;
            background: #3b82f6;
            transition: width 0.1s linear;
            width: 0%;
        }

        /* Export section */
        .export-actions {
            position: sticky;
            bottom: 0;
            background: white;
            padding: 16px 20px;
            border-top: 1px solid #e5e7eb;
            border-left: 1px solid #e5e7eb;
        }

        .export-actions h3 {
            font-size: 1rem;
            font-weight: 500;
            color: #374151;
            margin-bottom: 12px;
        }

        .export-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .export-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 8px 12px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            background: white;
            color: #374151;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.75rem;
            font-weight: 500;
            text-decoration: none;
        }

        .export-btn:hover {
            background: #f9fafb;
            border-color: #9ca3af;
        }

        .quick-copy {
            background: #10b981;
            color: white;
            border-color: #10b981;
            grid-column: span 2;
            margin-bottom: 8px;
        }

        .quick-copy:hover {
            background: #059669;
        }

        /* Responsive design */
        @media (max-width: 1024px) {
            .controls-sidebar {
                width: 320px;
            }
            
            .gradient-display {
                width: 320px;
                height: 427px;
            }
        }

        @media (max-width: 768px) {
            .app-container {
                flex-direction: column;
                height: auto;
                min-height: 100vh;
            }
            
            body {
                overflow: auto;
            }
            
            .gradient-section {
                height: 60vh;
                min-height: 400px;
            }
            
            .controls-sidebar {
                width: 100%;
                height: auto;
                border-left: none;
                border-top: 1px solid #e5e7eb;
            }
            
            .export-actions {
                position: static;
                border-left: none;
            }
        }

        /* Scrollbar styling */
        .controls-sidebar::-webkit-scrollbar {
            width: 6px;
        }

        .controls-sidebar::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        .controls-sidebar::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 3px;
        }

        .controls-sidebar::-webkit-scrollbar-thumb:hover {
            background: #a8a8a8;
        }

        /* Disabled state */
        .disabled {
            opacity: 0.5;
            pointer-events: none;
        }

        /* Success states */
        .copied {
            background: #10b981 !important;
            color: white !important;
            border-color: #10b981 !important;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Main gradient display -->
        <div class="gradient-section">
            <div class="gradient-display" id="gradientDisplay">
                <canvas id="gradient-canvas" width="400" height="533" style="width: 100%; height: 100%; border-radius: 12px;"></canvas>
                <div id="time-badge" class="time-badge" style="display: none;"></div>
            </div>
            
            <div class="gradient-info-bar" id="gradientInfoBar">
                <div class="color-palette-mini" id="colorPaletteMini"></div>
                <div class="css-preview" id="cssPreview"></div>
            </div>
        </div>

        <!-- Controls sidebar -->
        <div class="controls-sidebar">
            <div class="sidebar-header">
                <h1>Gradient Generator</h1>
                <div class="mode-selector">
                    <button class="mode-btn active" data-mode="image">🖼️ Image</button>
                    <button class="mode-btn" data-mode="time">🌅 Time</button>
                </div>
            </div>

            <div class="sidebar-content">
                <!-- Image Mode -->
                <div class="mode-content active" id="image-mode">
                    <div class="control-section">
                        <h3>📁 Upload Image</h3>
                        <div class="upload-area" id="uploadArea">
                            <div class="upload-text">Drop image or click</div>
                            <div class="upload-hint">JPG, PNG, WebP • Max 10MB</div>
                        </div>
                        <input type="file" id="fileInput" accept="image/*">
                        
                        <div id="previewSection" style="display: none;">
                            <img id="imagePreview" class="image-preview" alt="Preview">
                        </div>
                    </div>

                    <div class="control-section" id="imageControls" style="display: none;">
                        <h3>⚙️ Settings</h3>
                        <div class="control-group">
                            <label>Atmospheric Curve</label>
                            <div class="control-row">
                                <input type="range" id="atmosphericIntensity" min="2" max="6" value="4" step="0.5">
                                <span class="value-display" id="atmosphericValue">4x</span>
                            </div>
                        </div>
                        <button onclick="analyzeImage()">🎨 Generate Gradient</button>
                    </div>
                </div>

                <!-- Time Mode -->
                <div class="mode-content" id="time-mode">
                    <div class="control-section">
                        <h3>⏰ Time Selection</h3>
                        <div class="control-group">
                            <label for="time-input">Select Time</label>
                            <input id="time-input" type="time" value="12:00" />
                        </div>
                        <button id="current-time-btn">🕐 Use Current Time</button>
                        <div id="time-display" style="margin-top: 8px; font-size: 0.875rem; color: #6b7280;"></div>
                    </div>

                    <div class="control-section">
                        <h3>⚡ Quick Presets</h3>
                        <div class="presets-grid" id="presets-grid">
                            <!-- Preset buttons will be generated here -->
                        </div>
                    </div>

                    <div class="control-section">
                        <h3>✨ Legacy Effects</h3>
                        <div class="toggle-row">
                            <div id="effects-toggle" class="toggle-switch"></div>
                            <label>Enable optical effects</label>
                        </div>
                        
                        <div id="effects-controls" class="disabled">
                            <div class="control-group">
                                <label>Effect Type</label>
                                <select id="effectType">
                                    <option value="interference">Interference</option>
                                    <option value="prismatic">Prismatic</option>
                                    <option value="hybrid">Hybrid</option>
                                    <option value="filmgrain">Film Grain</option>
                                </select>
                            </div>

                            <div class="control-group">
                                <label>Intensity</label>
                                <div class="control-row">
                                    <input type="range" id="effectIntensity" min="10" max="60" value="25">
                                    <span class="value-display" id="effectIntensityVal">25</span>
                                </div>
                            </div>

                            <div class="control-group">
                                <label>Pattern Scale</label>
                                <div class="control-row">
                                    <input type="range" id="patternScale" min="15" max="80" value="30">
                                    <span class="value-display" id="patternScaleVal">30</span>
                                </div>
                            </div>

                            <div class="control-group">
                                <label>Organic Variation</label>
                                <div class="control-row">
                                    <input type="range" id="organicVariation" min="0" max="50" value="20">
                                    <span class="value-display" id="organicVariationVal">20%</span>
                                </div>
                            </div>

                            <div class="control-group">
                                <label>Grain Size</label>
                                <div class="control-row">
                                    <input type="range" id="grainSize" min="1" max="8" value="3">
                                    <span class="value-display" id="grainSizeVal">3</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="control-section">
                        <h3>🎨 Material Filters</h3>
                        <div class="toggle-row">
                            <div id="enhanced-effects-toggle" class="toggle-switch"></div>
                            <label>Enable material filters</label>
                        </div>
                        
                        <div id="enhanced-effects-controls" class="disabled">
                            <div class="control-group">
                                <label>Filter Type</label>
                                <select id="enhancedFilterType">
                                    <option value="none">None</option>
                                    <option value="subtleGrain">Subtle Film Grain</option>
                                    <option value="fabricWeave">Fabric Weave</option>
                                    <option value="paperTexture">Paper Texture</option>
                                    <option value="crosshatch">Crosshatch Etching</option>
                                    <option value="brushStroke">Brush Strokes</option>
                                    <option value="linen">Linen Canvas</option>
                                    <option value="metallic">Metallic Finish</option>
                                    <option value="concrete">Concrete Surface</option>
                                    <option value="velvet">Velvet Touch</option>
                                    <option value="interference">Light Interference</option>
                                </select>
                            </div>

                            <div class="control-group">
                                <label>Intensity</label>
                                <div class="control-row">
                                    <input type="range" id="enhancedIntensity" min="1" max="100" value="25">
                                    <span class="value-display" id="enhancedIntensityValue">25</span>
                                </div>
                            </div>

                            <div class="control-group">
                                <label>Opacity</label>
                                <div class="control-row">
                                    <input type="range" id="enhancedOpacity" min="10" max="100" value="60">
                                    <span class="value-display" id="enhancedOpacityValue">60%</span>
                                </div>
                            </div>

                            <div class="control-group">
                                <label>Scale</label>
                                <div class="control-row">
                                    <input type="range" id="enhancedScale" min="1" max="50" value="15">
                                    <span class="value-display" id="enhancedScaleValue">15</span>
                                </div>
                            </div>

                            <div class="enhanced-presets">
                                <button class="enhanced-preset-btn" data-preset="subtle">Subtle</button>
                                <button class="enhanced-preset-btn" data-preset="moderate">Moderate</button>
                                <button class="enhanced-preset-btn" data-preset="bold">Bold</button>
                                <button class="enhanced-preset-btn" data-preset="extreme">Extreme</button>
                            </div>
                        </div>
                    </div>

                    <div class="control-section">
                        <h3>🎬 Animation</h3>
                        <div class="animation-controls">
                            <div class="control-group">
                                <label for="start-time">Start Time</label>
                                <input id="start-time" type="time" value="06:00" />
                            </div>
                            <div class="control-group">
                                <label for="end-time">End Time</label>
                                <input id="end-time" type="time" value="20:00" />
                            </div>
                        </div>
                        
                        <div class="control-group">
                            <label for="duration">Duration</label>
                            <select id="duration">
                                <option value="5">5 seconds</option>
                                <option value="10" selected>10 seconds</option>
                                <option value="15">15 seconds</option>
                                <option value="30">30 seconds</option>
                            </select>
                        </div>
                        
                        <div class="animation-buttons">
                            <button id="play-btn" class="play-btn">▶️ Play</button>
                            <button id="stop-btn" class="stop-btn">⏹️ Stop</button>
                        </div>
                        
                        <div class="animation-progress">
                            <div id="animation-progress-bar" class="animation-progress-bar"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Export actions -->
            <div class="export-actions" id="exportActions" style="display: none;">
                <h3>🚀 Export</h3>
                <button class="export-btn quick-copy" onclick="copyCSS()">📋 Copy CSS</button>
                <div class="export-grid">
                    <button class="export-btn" onclick="exportImage()">🖼️ PNG</button>
                    <button class="export-btn" onclick="exportSVG()">📄 SVG</button>
                    <button class="export-btn" onclick="exportCSS()">💾 CSS</button>
                    <button class="export-btn" onclick="exportJSON()">📊 JSON</button>
                </div>
            </div>
        </div>
    </div>

    <script>
      // All the existing JavaScript from your original code goes here
// I'll include the essential parts to make this work

// Global variables
let currentImage = null;
let extractedColors = [];
let currentMode = 'image';
let animationInterval;
let isAnimating = false;
let effectsEnabled = false;
let enhancedEffectsEnabled = false;
let currentGradientData = null;
let selectedExportFormat = 'png';

// Add after your existing global variables
let invisiblePatternCanvas = null;
let invisiblePatternCtx = null;

// Initialize invisible pattern canvas
function initInvisiblePatternCanvas() {
    invisiblePatternCanvas = document.createElement('canvas');
    invisiblePatternCanvas.width = 400;
    invisiblePatternCanvas.height = 533;
    invisiblePatternCtx = invisiblePatternCanvas.getContext('2d');
    
    // Don't append to DOM - keep it invisible!
    // This canvas exists only in memory
}

// Generate pattern on invisible canvas with transparent background
function generateInvisiblePatternOverlay() {
    if (!invisiblePatternCanvas) initInvisiblePatternCanvas();
    
    // Clear with transparent background
    invisiblePatternCtx.clearRect(0, 0, 400, 533);
    
    const filterValue = enhancedFilterType.value;
    if (filterValue === 'none') return;
    
    const params = {
        intensity: parseInt(enhancedIntensity.value),
        opacity: parseInt(enhancedOpacity.value),
        scale: parseInt(enhancedScale.value)
    };
    
    // Create pattern with transparency
    const patternImageData = invisiblePatternCtx.createImageData(400, 533);
    generatePatternWithTransparency(patternImageData.data, 400, 533, filterValue, params);
    invisiblePatternCtx.putImageData(patternImageData, 0, 0);
}

// Enhanced pattern generation with proper transparency
function generatePatternWithTransparency(data, width, height, filterType, params) {
    const { intensity, opacity, scale } = params;
    
    // Initialize all pixels as transparent
    for (let i = 0; i < data.length; i += 4) {
        data[i + 3] = 0; // Alpha = 0 (transparent)
    }
    
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            const index = (y * width + x) * 4;
            let patternValue = getPatternValue(x, y, filterType, params);
            
            // Only create visible pixels where pattern has significant value
            if (Math.abs(patternValue) > 0.05) {
                const alpha = Math.min(255, Math.abs(patternValue * intensity * opacity * 0.01));
                
                if (patternValue > 0) {
                    // Light pattern areas - white with alpha
                    data[index] = 255;
                    data[index + 1] = 255;
                    data[index + 2] = 255;
                    data[index + 3] = alpha;
                } else {
                    // Dark pattern areas - black with alpha
                    data[index] = 0;
                    data[index + 1] = 0;
                    data[index + 2] = 0;
                    data[index + 3] = alpha;
                }
            }
        }
    }
}

// Unified pattern value calculator
function getPatternValue(x, y, filterType, params) {
    const { scale } = params;
    
    switch (filterType) {
        case 'subtleGrain':
            return generateSubtleGrainValue(x, y, scale);
        case 'fabricWeave':
            return generateFabricWeaveValue(x, y, scale);
        case 'paperTexture':
            return generatePaperTextureValue(x, y, scale);
        case 'crosshatch':
            return generateCrosshatchValue(x, y, scale);
        case 'brushStroke':
            return generateBrushStrokeValue(x, y, scale);
        case 'linen':
            return generateLinenValue(x, y, scale);
        case 'metallic':
            return generateMetallicValue(x, y, scale);
        case 'concrete':
            return generateConcreteValue(x, y, scale);
        case 'velvet':
            return generateVelvetValue(x, y, scale);
        case 'interference':
            return generateInterferenceValue(x, y, scale);
        default:
            return 0;
    }
}

// Pattern value generators (return -1 to 1)
function generateSubtleGrainValue(x, y, scale) {
    const coarse = pseudoRandom(Math.floor(x / scale), Math.floor(y / scale), 12345) - 0.5;
    const fine = pseudoRandom(x, y, 54321) - 0.5;
    const medium = pseudoRandom(Math.floor(x / (scale * 0.5)), Math.floor(y / (scale * 0.5)), 98765) - 0.5;
    return (coarse * 0.4 + fine * 0.3 + medium * 0.3) * 2;
}

function generateFabricWeaveValue(x, y, scale) {
    const warp = Math.sin(x * Math.PI / scale) > 0;
    const weft = Math.sin(y * Math.PI / scale) > 0;
    
    if (warp && !weft) return 0.6;
    else if (!warp && weft) return -0.6;
    else if (warp && weft) return 0.2;
    else return -0.2;
}

function generatePaperTextureValue(x, y, scale) {
    const fiber1 = perlinNoise(x, y, scale) - 0.5;
    const fiber2 = perlinNoise(x + 1000, y + 1000, scale * 0.5) - 0.5;
    const fiber3 = pseudoRandom(Math.floor(x / 2), Math.floor(y / 2), 13579) - 0.5;
    return (fiber1 * 0.5 + fiber2 * 0.3 + fiber3 * 0.2) * 2;
}

function generateCrosshatchValue(x, y, scale) {
    const line1 = Math.sin(x * Math.PI / scale);
    const line2 = Math.sin(y * Math.PI / scale);
    const crosshatch = (Math.abs(line1) < 0.3 ? -0.6 : 0.2) + (Math.abs(line2) < 0.3 ? -0.6 : 0.2);
    return crosshatch * 0.5;
}

function generateBrushStrokeValue(x, y, scale) {
    const strokePattern = Math.sin(x * Math.PI / scale) * Math.exp(-Math.abs((x % scale) - scale/2) / (scale * 0.3));
    const brushTexture = perlinNoise(x, y, scale * 0.3) * 0.5 + strokePattern * 0.5;
    return brushTexture;
}

function generateLinenValue(x, y, scale) {
    const warp = Math.sin(x * Math.PI / scale) + perlinNoise(x, y, scale * 0.5) * 0.3;
    const weft = Math.sin(y * Math.PI / scale) + perlinNoise(x + 500, y + 500, scale * 0.5) * 0.3;
    return (warp * weft) * 0.5;
}

function generateMetallicValue(x, y, scale) {
    const brushLines = Math.sin(x * Math.PI / (scale * 0.2)) * 0.3;
    const scratches = pseudoRandom(Math.floor(x / 3), Math.floor(y / 20), 11111) * 0.2;
    const microTexture = perlinNoise(x, y, scale * 0.1) * 0.1;
    return brushLines + scratches + microTexture;
}

function generateConcreteValue(x, y, scale) {
    const aggregate = worleyNoise(x, y, scale) * 0.6;
    const surface = perlinNoise(x, y, scale * 0.3) * 0.4;
    const pits = pseudoRandom(Math.floor(x / 5), Math.floor(y / 5), 22222) * 0.2;
    return (aggregate + surface + pits) - 0.5;
}

function generateVelvetValue(x, y, scale) {
    const pile = Math.sin(x * Math.PI / scale) * Math.exp(-Math.abs((y % scale) - scale/2) / (scale * 0.4));
    const softness = perlinNoise(x, y, scale * 0.5) * 0.2;
    return (pile + softness) * 0.8;
}

function generateInterferenceValue(x, y, scale) {
    const wave1 = Math.sin(x * Math.PI / scale) * Math.cos(y * Math.PI / scale);
    const wave2 = Math.sin((x + y) * Math.PI / (scale * 1.2)) * Math.cos((x - y) * Math.PI / (scale * 1.2));
    const wave3 = Math.sin(x * Math.PI / (scale * 0.7)) * Math.sin(y * Math.PI / (scale * 0.7));
    return (wave1 * 0.5 + wave2 * 0.3 + wave3 * 0.2);
}

// Modified enhanced filter application
function applyEnhancedFilter() {
    const filterValue = enhancedFilterType.value;
    if (filterValue === 'none') return;
    
    // Generate pattern on invisible canvas
    generateInvisiblePatternOverlay();
    
    // Apply pattern to main gradient canvas using composite operation
    gradientCtx.globalCompositeOperation = 'overlay';
    gradientCtx.drawImage(invisiblePatternCanvas, 0, 0);
    gradientCtx.globalCompositeOperation = 'source-over';
}

// PNG Pattern Export (with transparency)
function exportPatternPNG() {
    if (!currentGradientData || !enhancedEffectsEnabled || enhancedFilterType.value === 'none') {
        alert('Please enable material filters and select a pattern first!');
        return;
    }
    
    // Create high-resolution export canvas
    const exportCanvas = document.createElement('canvas');
    exportCanvas.width = 800;
    exportCanvas.height = 1066;
    const exportCtx = exportCanvas.getContext('2d');
    
    const params = {
        intensity: parseInt(enhancedIntensity.value),
        opacity: parseInt(enhancedOpacity.value),
        scale: parseInt(enhancedScale.value) * 2 // Scale up for higher resolution
    };
    
    // Generate high-res pattern
    const exportImageData = exportCtx.createImageData(800, 1066);
    generatePatternWithTransparency(exportImageData.data, 800, 1066, enhancedFilterType.value, params);
    exportCtx.putImageData(exportImageData, 0, 0);
    
    // Export as PNG with transparency
    const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
    const filename = `pattern-${enhancedFilterType.value}-${timestamp}.png`;
    
    exportCanvas.toBlob((blob) => {
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        link.click();
        URL.revokeObjectURL(url);
    }, 'image/png');
}

// SVG Pattern Export (vector-based)
function exportPatternSVG() {
    if (!currentGradientData || !enhancedEffectsEnabled || enhancedFilterType.value === 'none') {
        alert('Please enable material filters and select a pattern first!');
        return;
    }
    
    const filterValue = enhancedFilterType.value;
    const params = {
        intensity: parseInt(enhancedIntensity.value),
        opacity: parseInt(enhancedOpacity.value) / 100,
        scale: parseInt(enhancedScale.value)
    };
    
    let svgContent = generatePatternSVG(filterValue, params);
    
    const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
    const filename = `pattern-${filterValue}-${timestamp}.svg`;
    downloadFile(svgContent, filename, 'image/svg+xml');
}

// SVG pattern generator
function generatePatternSVG(filterType, params) {
    const { scale, opacity } = params;
    const width = 800;
    const height = 1066;
    
    let patternDef = '';
    
    switch (filterType) {
        case 'fabricWeave':
            patternDef = `
    <pattern id="pattern" patternUnits="userSpaceOnUse" width="${scale * 2}" height="${scale * 2}">
      <rect width="${scale}" height="${scale}" fill="rgba(255,255,255,${opacity * 0.3})"/>
      <rect x="${scale}" y="${scale}" width="${scale}" height="${scale}" fill="rgba(255,255,255,${opacity * 0.3})"/>
      <rect x="${scale}" y="0" width="${scale}" height="${scale}" fill="rgba(0,0,0,${opacity * 0.3})"/>
      <rect x="0" y="${scale}" width="${scale}" height="${scale}" fill="rgba(0,0,0,${opacity * 0.3})"/>
    </pattern>`;
            break;
            
        case 'crosshatch':
            const strokeWidth = Math.max(1, scale * 0.1);
            patternDef = `
    <pattern id="pattern" patternUnits="userSpaceOnUse" width="${scale}" height="${scale}">
      <line x1="0" y1="0" x2="${scale}" y2="${scale}" stroke="rgba(0,0,0,${opacity})" stroke-width="${strokeWidth}"/>
      <line x1="0" y1="${scale}" x2="${scale}" y2="0" stroke="rgba(0,0,0,${opacity})" stroke-width="${strokeWidth}"/>
    </pattern>`;
            break;
            
        case 'linen':
            patternDef = `
    <pattern id="pattern" patternUnits="userSpaceOnUse" width="${scale}" height="${scale}">
      <rect width="100%" height="100%" fill="rgba(240,240,240,${opacity * 0.3})"/>
      <circle cx="${scale * 0.25}" cy="${scale * 0.25}" r="1" fill="rgba(200,200,200,${opacity})"/>
      <circle cx="${scale * 0.75}" cy="${scale * 0.75}" r="1" fill="rgba(200,200,200,${opacity})"/>
      <line x1="0" y1="${scale * 0.5}" x2="${scale}" y2="${scale * 0.5}" stroke="rgba(220,220,220,${opacity})" stroke-width="0.5"/>
      <line x1="${scale * 0.5}" y1="0" x2="${scale * 0.5}" y2="${scale}" stroke="rgba(220,220,220,${opacity})" stroke-width="0.5"/>
    </pattern>`;
            break;
            
        default:
            // Fallback noise pattern
            patternDef = `
    <pattern id="pattern" patternUnits="userSpaceOnUse" width="${scale}" height="${scale}">
      <rect width="100%" height="100%" fill="rgba(128,128,128,${opacity * 0.1})"/>
    </pattern>`;
            break;
    }
    
    return `<?xml version="1.0" encoding="UTF-8"?>
<svg width="${width}" height="${height}" viewBox="0 0 ${width} ${height}" xmlns="http://www.w3.org/2000/svg">
  <defs>
    ${patternDef}
  </defs>
  <rect width="100%" height="100%" fill="url(#pattern)"/>
</svg>`;
}

// Add pattern export buttons to the export section
function addPatternExportButtons() {
    const exportGrid = document.querySelector('.export-grid');
    
    // PNG Pattern Export Button
    const pngPatternBtn = document.createElement('button');
    pngPatternBtn.className = 'export-btn';
    pngPatternBtn.innerHTML = '🎨 Pattern PNG';
    pngPatternBtn.onclick = exportPatternPNG;
    exportGrid.appendChild(pngPatternBtn);
    
    // SVG Pattern Export Button
    const svgPatternBtn = document.createElement('button');
    svgPatternBtn.className = 'export-btn';
    svgPatternBtn.innerHTML = '🎯 Pattern SVG';
    svgPatternBtn.onclick = exportPatternSVG;
    exportGrid.appendChild(svgPatternBtn);
}

// Initialize everything
function initPatternExport() {
    initInvisiblePatternCanvas();
    addPatternExportButtons();
}

// Call this when the page loads
document.addEventListener('DOMContentLoaded', initPatternExport);

// Time-based gradient configurations
const timeGradients = {
    dawn: {
        colors: ["#FFB347", "#FF6B6B", "#4ECDC4", "#45B7D1"],
        stops: [0, 30, 70, 100],
        name: "Dawn",
    },
    morning: {
        colors: ["#87CEEB", "#98D8E8", "#F0F8FF"],
        stops: [0, 50, 100],
        name: "Morning",
    },
    midday: {
        colors: ["#87CEEB", "#B0E0E6", "#E6F3FF"],
        stops: [0, 50, 100],
        name: "Midday",
    },
    afternoon: {
        colors: ["#FFA500", "#FFD700", "#87CEEB", "#E6F3FF"],
        stops: [0, 25, 60, 100],
        name: "Afternoon",
    },
    golden: {
        colors: ["#FF8C00", "#FFD700", "#FF6347", "#FF69B4"],
        stops: [0, 30, 70, 100],
        name: "Golden Hour",
    },
    sunset: {
        colors: ["#FF4500", "#FF6347", "#FF1493", "#8A2BE2"],
        stops: [0, 30, 70, 100],
        name: "Sunset",
    },
    dusk: {
        colors: ["#4B0082", "#663399", "#2F4F4F"],
        stops: [0, 50, 100],
        name: "Dusk",
    },
    night: {
        colors: ["#000428", "#004e92", "#191970"],
        stops: [0, 50, 100],
        name: "Night",
    },
};

const presetTimes = [
    { time: "06:00", label: "6:00 AM" },
    { time: "08:00", label: "8:00 AM" },
    { time: "12:00", label: "12:00 PM" },
    { time: "15:00", label: "3:00 PM" },
    { time: "18:00", label: "6:00 PM" },
    { time: "19:30", label: "7:30 PM" },
    { time: "21:00", label: "9:00 PM" },
    { time: "23:00", label: "11:00 PM" },
];

// DOM elements
const modeButtons = document.querySelectorAll('.mode-btn');
const modeContents = document.querySelectorAll('.mode-content');
const gradientCanvas = document.getElementById('gradient-canvas');
const gradientCtx = gradientCanvas.getContext('2d');
const gradientInfoBar = document.getElementById('gradientInfoBar');
const colorPaletteMini = document.getElementById('colorPaletteMini');
const cssPreview = document.getElementById('cssPreview');
const exportActions = document.getElementById('exportActions');

// Image mode elements
const uploadArea = document.getElementById('uploadArea');
const fileInput = document.getElementById('fileInput');
const previewSection = document.getElementById('previewSection');
const imagePreview = document.getElementById('imagePreview');
const imageControls = document.getElementById('imageControls');
const atmosphericSlider = document.getElementById('atmosphericIntensity');
const atmosphericValue = document.getElementById('atmosphericValue');

// Time mode elements
const timeInput = document.getElementById('time-input');
const timeDisplay = document.getElementById('time-display');
const currentTimeBtn = document.getElementById('current-time-btn');
const presetsGrid = document.getElementById('presets-grid');
const timeBadge = document.getElementById('time-badge');
const effectsToggle = document.getElementById('effects-toggle');
const effectsControls = document.getElementById('effects-controls');
const enhancedEffectsToggle = document.getElementById('enhanced-effects-toggle');
const enhancedEffectsControls = document.getElementById('enhanced-effects-controls');

// Animation elements
const playBtn = document.getElementById('play-btn');
const stopBtn = document.getElementById('stop-btn');
const progressBar = document.getElementById('animation-progress-bar');

// Enhanced filter presets
const enhancedPresets = {
    subtle: { intensity: 15, opacity: 40, scale: 20 },
    moderate: { intensity: 35, opacity: 65, scale: 15 },
    bold: { intensity: 60, opacity: 85, scale: 10 },
    extreme: { intensity: 85, opacity: 95, scale: 5 }
};

// Effect control elements and values
const effectType = document.getElementById('effectType');
const effectIntensity = document.getElementById('effectIntensity');
const patternScale = document.getElementById('patternScale');
const organicVariation = document.getElementById('organicVariation');
const grainSize = document.getElementById('grainSize');
const effectIntensityVal = document.getElementById('effectIntensityVal');
const patternScaleVal = document.getElementById('patternScaleVal');
const organicVariationVal = document.getElementById('organicVariationVal');
const grainSizeVal = document.getElementById('grainSizeVal');

// Enhanced effects elements
const enhancedFilterType = document.getElementById('enhancedFilterType');
const enhancedIntensity = document.getElementById('enhancedIntensity');
const enhancedOpacity = document.getElementById('enhancedOpacity');
const enhancedScale = document.getElementById('enhancedScale');
const enhancedIntensityValue = document.getElementById('enhancedIntensityValue');
const enhancedOpacityValue = document.getElementById('enhancedOpacityValue');
const enhancedScaleValue = document.getElementById('enhancedScaleValue');

// Utility functions
function getCurrentTime() {
    const now = new Date();
    const hours = now.getHours().toString().padStart(2, '0');
    const minutes = now.getMinutes().toString().padStart(2, '0');
    return `${hours}:${minutes}`;
}

function timeToMinutes(timeString) {
    const [hours, minutes] = timeString.split(":").map(Number);
    return hours * 60 + minutes;
}

function getTimeCategory(timeString) {
    const [hours, minutes] = timeString.split(":").map(Number);
    const totalMinutes = hours * 60 + minutes;

    if (totalMinutes >= 300 && totalMinutes < 420) return "dawn";
    if (totalMinutes >= 420 && totalMinutes < 600) return "morning";
    if (totalMinutes >= 600 && totalMinutes < 900) return "midday";
    if (totalMinutes >= 900 && totalMinutes < 1020) return "afternoon";
    if (totalMinutes >= 1020 && totalMinutes < 1140) return "golden";
    if (totalMinutes >= 1140 && totalMinutes < 1230) return "sunset";
    if (totalMinutes >= 1230 && totalMinutes < 1320) return "dusk";
    return "night";
}

function formatTime(time24) {
    const [hours, minutes] = time24.split(":").map(Number);
    const period = hours >= 12 ? "PM" : "AM";
    const displayHours = hours === 0 ? 12 : hours > 12 ? hours - 12 : hours;
    return `${displayHours}:${minutes.toString().padStart(2, "0")} ${period}`;
}

function getLuminance(rgb) {
    return 0.299 * rgb[0] + 0.587 * rgb[1] + 0.114 * rgb[2];
}

// Export dimension function
function getExportDimensions() {
    return { width: 800, height: 1066 };
}

// Enhanced noise functions
function pseudoRandom(x, y, seed = 12345) {
    let hash = seed;
    hash = ((hash ^ x) * 16777619) >>> 0;
    hash = ((hash ^ y) * 16777619) >>> 0;
    hash = ((hash ^ (hash >>> 16)) * 2246822507) >>> 0;
    hash = ((hash ^ (hash >>> 13)) * 3266489909) >>> 0;
    hash = (hash ^ (hash >>> 16)) >>> 0;
    return (hash / 4294967296);
}

function perlinNoise(x, y, scale) {
    const xi = Math.floor(x / scale);
    const yi = Math.floor(y / scale);
    const xf = (x / scale) - xi;
    const yf = (y / scale) - yi;
    
    const u = xf * xf * (3 - 2 * xf);
    const v = yf * yf * (3 - 2 * yf);
    
    const n00 = pseudoRandom(xi, yi);
    const n10 = pseudoRandom(xi + 1, yi);
    const n01 = pseudoRandom(xi, yi + 1);
    const n11 = pseudoRandom(xi + 1, yi + 1);
    
    const nx0 = n00 * (1 - u) + n10 * u;
    const nx1 = n01 * (1 - u) + n11 * u;
    
    return nx0 * (1 - v) + nx1 * v;
}

function worleyNoise(x, y, scale) {
    const cellX = Math.floor(x / scale);
    const cellY = Math.floor(y / scale);
    let minDist = Infinity;
    
    for (let i = -1; i <= 1; i++) {
        for (let j = -1; j <= 1; j++) {
            const pointX = (cellX + i) * scale + pseudoRandom(cellX + i, cellY + j, 54321) * scale;
            const pointY = (cellY + j) * scale + pseudoRandom(cellX + i, cellY + j, 98765) * scale;
            const dist = Math.sqrt((x - pointX) ** 2 + (y - pointY) ** 2);
            minDist = Math.min(minDist, dist);
        }
    }
    
    return minDist / scale;
}

function filmGrainNoise(x, y, grainSize, intensity) {
    const clusterX = Math.floor(x / grainSize);
    const clusterY = Math.floor(y / grainSize);
    
    const coarseGrain = pseudoRandom(clusterX, clusterY, 12345);
    const fineGrain = pseudoRandom(x, y, 54321);
    const mediumGrain = pseudoRandom(Math.floor(x / 2), Math.floor(y / 2), 98765);
    
    const combinedNoise = (coarseGrain * 0.5 + fineGrain * 0.3 + mediumGrain * 0.2);
    const displacement = (combinedNoise - 0.5) * intensity;
    
    return displacement;
}

// Enhanced filter functions
function subtleGrainFilter(imageData, params) {
    const data = imageData.data;
    const { intensity, opacity, scale } = params;
    
    for (let i = 0; i < data.length; i += 4) {
        const x = (i / 4) % 400;
        const y = Math.floor((i / 4) / 400);
        
        const coarseGrain = pseudoRandom(Math.floor(x / scale), Math.floor(y / scale), 12345) - 0.5;
        const fineGrain = pseudoRandom(x, y, 54321) - 0.5;
        const mediumGrain = pseudoRandom(Math.floor(x / (scale * 0.5)), Math.floor(y / (scale * 0.5)), 98765) - 0.5;
        
        const combinedGrain = (coarseGrain * 0.4 + fineGrain * 0.3 + mediumGrain * 0.3) * intensity * 0.3;
        const alpha = opacity / 100;
        
        data[i] = Math.max(0, Math.min(255, data[i] + combinedGrain * alpha));
        data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + combinedGrain * alpha));
        data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + combinedGrain * alpha));
    }
}

function fabricWeaveFilter(imageData, params) {
    const data = imageData.data;
    const { intensity, opacity, scale } = params;
    const direction = params.direction || 0;
    const organic = params.organic || 20;
    const dirRad = (direction * Math.PI) / 180;
    
    for (let i = 0; i < data.length; i += 4) {
        const x = (i / 4) % 400;
        const y = Math.floor((i / 4) / 400);
        
        const rotX = x * Math.cos(dirRad) - y * Math.sin(dirRad);
        const rotY = x * Math.sin(dirRad) + y * Math.cos(dirRad);
        
        const organicX = rotX + perlinNoise(x, y, scale * 2) * organic * 0.1;
        const organicY = rotY + perlinNoise(x + 100, y + 100, scale * 2) * organic * 0.1;
        
        const warpThread = Math.sin(organicX * Math.PI / scale) > 0;
        const weftThread = Math.sin(organicY * Math.PI / scale) > 0;
        
        let weaveValue = 0;
        if (warpThread && !weftThread) weaveValue = 0.3;
        else if (!warpThread && weftThread) weaveValue = -0.3;
        else if (warpThread && weftThread) weaveValue = 0.1;
        else weaveValue = -0.1;
        
        const effect = weaveValue * intensity * (opacity / 100);
        
        data[i] = Math.max(0, Math.min(255, data[i] + effect));
        data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + effect));
        data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + effect));
    }
}

function paperTextureFilter(imageData, params) {
    const data = imageData.data;
    const { intensity, opacity, scale } = params;
    const organic = params.organic || 20;
    
    for (let i = 0; i < data.length; i += 4) {
        const x = (i / 4) % 400;
        const y = Math.floor((i / 4) / 400);
        
        const fiber1 = perlinNoise(x, y, scale) - 0.5;
        const fiber2 = perlinNoise(x + 1000, y + 1000, scale * 0.5) - 0.5;
        const fiber3 = pseudoRandom(Math.floor(x / 2), Math.floor(y / 2), 13579) - 0.5;
        
        const organicNoise = perlinNoise(x, y, scale * 3) * organic * 0.01;
        
        const paperTexture = (fiber1 * 0.5 + fiber2 * 0.3 + fiber3 * 0.2 + organicNoise) * intensity * 0.2;
        const alpha = opacity / 100;
        
        data[i] = Math.max(0, Math.min(255, data[i] + paperTexture * alpha));
        data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + paperTexture * alpha));
        data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + paperTexture * alpha));
    }
}

function crosshatchFilter(imageData, params) {
    const data = imageData.data;
    const { intensity, opacity, scale } = params;
    const direction = params.direction || 0;
    const dirRad = (direction * Math.PI) / 180;
    
    for (let i = 0; i < data.length; i += 4) {
        const x = (i / 4) % 400;
        const y = Math.floor((i / 4) / 400);
        
        const line1 = Math.sin((x * Math.cos(dirRad) + y * Math.sin(dirRad)) * Math.PI / scale);
        const line2 = Math.sin((x * Math.cos(dirRad + Math.PI/2) + y * Math.sin(dirRad + Math.PI/2)) * Math.PI / scale);
        
        const crosshatch = (Math.abs(line1) < 0.3 ? -0.3 : 0.1) + (Math.abs(line2) < 0.3 ? -0.3 : 0.1);
        const effect = crosshatch * intensity * 0.1 * (opacity / 100);
        
        data[i] = Math.max(0, Math.min(255, data[i] + effect));
        data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + effect));
        data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + effect));
    }
}

function brushStrokeFilter(imageData, params) {
    const data = imageData.data;
    const { intensity, opacity, scale } = params;
    const direction = params.direction || 0;
    const organic = params.organic || 20;
    const dirRad = (direction * Math.PI) / 180;
    
    for (let i = 0; i < data.length; i += 4) {
        const x = (i / 4) % 400;
        const y = Math.floor((i / 4) / 400);
        
        const organicDir = dirRad + perlinNoise(x, y, scale * 2) * organic * 0.01;
        const strokeX = x * Math.cos(organicDir) + y * Math.sin(organicDir);
        
        const strokePattern = Math.sin(strokeX * Math.PI / scale) * Math.exp(-Math.abs(strokeX % scale - scale/2) / (scale * 0.3));
        const brushTexture = perlinNoise(x, y, scale * 0.3) * 0.5 + strokePattern * 0.5;
        
        const effect = brushTexture * intensity * 0.15 * (opacity / 100);
        
        data[i] = Math.max(0, Math.min(255, data[i] + effect));
        data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + effect));
        data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + effect));
    }
}

function linenFilter(imageData, params) {
    const data = imageData.data;
    const { intensity, opacity, scale } = params;
    const organic = params.organic || 20;
    
    for (let i = 0; i < data.length; i += 4) {
        const x = (i / 4) % 400;
        const y = Math.floor((i / 4) / 400);
        
        const warp = Math.sin(x * Math.PI / scale) + perlinNoise(x, y, scale * 0.5) * 0.3;
        const weft = Math.sin(y * Math.PI / scale) + perlinNoise(x + 500, y + 500, scale * 0.5) * 0.3;
        
        const fiberNoise = perlinNoise(x, y, scale * 0.2) * organic * 0.01;
        
        const linenTexture = (warp * weft + fiberNoise) * intensity * 0.1;
        const alpha = opacity / 100;
        
        data[i] = Math.max(0, Math.min(255, data[i] + linenTexture * alpha));
        data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + linenTexture * alpha));
        data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + linenTexture * alpha));
    }
}

function metallicFilter(imageData, params) {
    const data = imageData.data;
    const { intensity, opacity, scale } = params;
    const direction = params.direction || 0;
    const dirRad = (direction * Math.PI) / 180;
    
    for (let i = 0; i < data.length; i += 4) {
        const x = (i / 4) % 400;
        const y = Math.floor((i / 4) / 400);
        
        const brushDirection = x * Math.cos(dirRad) + y * Math.sin(dirRad);
        const brushLines = Math.sin(brushDirection * Math.PI / (scale * 0.2)) * 0.1;
        
        const scratches = pseudoRandom(Math.floor(x / 3), Math.floor(y / 20), 11111) * 0.05;
        const microTexture = perlinNoise(x, y, scale * 0.1) * 0.02;
        
        const metalEffect = (brushLines + scratches + microTexture) * intensity * (opacity / 100);
        
        data[i] = Math.max(0, Math.min(255, data[i] + metalEffect));
        data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + metalEffect));
        data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + metalEffect));
    }
}

function concreteFilter(imageData, params) {
    const data = imageData.data;
    const { intensity, opacity, scale } = params;
    const organic = params.organic || 20;
    
    for (let i = 0; i < data.length; i += 4) {
        const x = (i / 4) % 400;
        const y = Math.floor((i / 4) / 400);
        
        const aggregate = worleyNoise(x, y, scale) * 0.3;
        const surface = perlinNoise(x, y, scale * 0.3) * 0.2;
        const pits = pseudoRandom(Math.floor(x / 5), Math.floor(y / 5), 22222) * 0.1;
        const organicVar = perlinNoise(x, y, scale * 2) * organic * 0.01;
        
        const concreteTexture = (aggregate + surface + pits + organicVar) * intensity * 0.1;
        const alpha = opacity / 100;
        
        data[i] = Math.max(0, Math.min(255, data[i] + concreteTexture * alpha));
        data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + concreteTexture * alpha));
        data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + concreteTexture * alpha));
    }
}

function velvetFilter(imageData, params) {
    const data = imageData.data;
    const { intensity, opacity, scale } = params;
    const direction = params.direction || 0;
    const organic = params.organic || 20;
    const dirRad = (direction * Math.PI) / 180;
    
    for (let i = 0; i < data.length; i += 4) {
        const x = (i / 4) % 400;
        const y = Math.floor((i / 4) / 400);
        
        const pileX = x * Math.cos(dirRad) + y * Math.sin(dirRad);
        const pileY = x * Math.sin(dirRad) - y * Math.cos(dirRad);
        
        const velvetPile = Math.sin(pileX * Math.PI / scale) * Math.exp(-Math.abs(pileY % scale - scale/2) / (scale * 0.4));
        const softness = perlinNoise(x, y, scale * 0.5) * organic * 0.005;
        
        const velvetTexture = (velvetPile + softness) * intensity * 0.08;
        const alpha = opacity / 100;
        
        data[i] = Math.max(0, Math.min(255, data[i] + velvetTexture * alpha));
        data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + velvetTexture * alpha));
        data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + velvetTexture * alpha));
    }
}

function interferenceFilter(imageData, params) {
    const data = imageData.data;
    const { intensity, opacity, scale } = params;
    
    for (let i = 0; i < data.length; i += 4) {
        const x = (i / 4) % 400;
        const y = Math.floor((i / 4) / 400);
        
        const wave1 = Math.sin(x * Math.PI / scale) * Math.cos(y * Math.PI / scale);
        const wave2 = Math.sin((x + y) * Math.PI / (scale * 1.2)) * Math.cos((x - y) * Math.PI / (scale * 1.2));
        const wave3 = Math.sin(x * Math.PI / (scale * 0.7)) * Math.sin(y * Math.PI / (scale * 0.7));
        
        const interference = (wave1 * 0.5 + wave2 * 0.3 + wave3 * 0.2) * intensity * 0.1;
        const alpha = opacity / 100;
        
        data[i] = Math.max(0, Math.min(255, data[i] + interference * alpha * 1.2));
        data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + interference * alpha));
        data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + interference * alpha * 0.8));
    }
}

function applyOpticalEffects(sourceCanvas, gradient) {
    const width = 400;
    const height = 533;
    const sourceCtx = sourceCanvas.getContext('2d');
    
    const intensity = parseInt(effectIntensity.value);
    const scale = parseInt(patternScale.value);
    const variation = parseInt(organicVariation.value) / 100;
    const grainSizeValue = parseInt(grainSize.value);
    
    const outputImageData = gradientCtx.createImageData(width, height);
    const outputData = outputImageData.data;
    
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            let displacementX = 0;
            let displacementY = 0;
            let colorModification = 0;
            
            const organicX = x + perlinNoise(x, y, 8) * variation * 10;
            const organicY = y + perlinNoise(x + 100, y + 100, 8) * variation * 10;
            
            switch (effectType.value) {
                case 'interference':
                    const pattern1 = Math.sin(organicX * Math.PI / scale) * Math.cos(organicY * Math.PI / scale);
                    const pattern2 = Math.sin((organicX + organicY) * Math.PI / (scale * 1.2)) * Math.cos((organicX - organicY) * Math.PI / (scale * 1.2));
                    const interference = pattern1 * pattern2;
                    displacementX = interference * intensity * 0.4;
                    displacementY = interference * intensity * 0.3;
                    break;
                    
                case 'prismatic':
                    const distance = Math.sqrt((x - width/2) ** 2 + (y - height/2) ** 2);
                    const angle = Math.atan2(y - height/2, x - width/2);
                    const prism1 = Math.sin(organicX * Math.PI / scale + angle);
                    const prism2 = Math.cos(organicY * Math.PI / scale + angle);
                    displacementX = prism1 * intensity * 0.3;
                    displacementY = prism2 * intensity * 0.3;
                    break;
                    
                case 'hybrid':
                    const hybridPattern1 = Math.sin(organicX * Math.PI / scale) * Math.cos(organicY * Math.PI / scale);
                    const hybridPattern2 = Math.sin((organicX + organicY) * Math.PI / (scale * 1.2)) * Math.cos((organicX - organicY) * Math.PI / (scale * 1.2));
                    const hybridInterference = hybridPattern1 * hybridPattern2;
                    
                    const hybridAngle = Math.atan2(y - height/2, x - width/2);
                    const hybridPrism = Math.sin(organicX * Math.PI / (scale * 0.8) + hybridAngle * 2);
                    
                    displacementX = (hybridInterference * 0.6 + hybridPrism * 0.4) * intensity * 0.35;
                    displacementY = (hybridInterference * 0.6 + hybridPrism * 0.4) * intensity * 0.25;
                    break;

                case 'filmgrain':
                    const grainDisplacementX = filmGrainNoise(x, y, grainSizeValue, intensity * 0.1);
                    const grainDisplacementY = filmGrainNoise(x + 123, y + 456, grainSizeValue, intensity * 0.1);
                    
                    const organicGrainX = perlinNoise(x, y, scale * 0.5) * variation * 2;
                    const organicGrainY = perlinNoise(x + 789, y + 012, scale * 0.5) * variation * 2;
                    
                    displacementX = grainDisplacementX + organicGrainX;
                    displacementY = grainDisplacementY + organicGrainY;
                    
                    colorModification = filmGrainNoise(x + 333, y + 666, grainSizeValue * 0.5, intensity * 0.3);
                    break;
            }
            
            const sourceX = Math.max(0, Math.min(width - 1, Math.round(x + displacementX)));
            const sourceY = Math.max(0, Math.min(height - 1, Math.round(y + displacementY)));
            
            const sourceImageData = sourceCtx.getImageData(sourceX, sourceY, 1, 1);
            const sourcePixel = sourceImageData.data;
            
            const outputIndex = (y * width + x) * 4;
            
            if (effectType.value === 'filmgrain') {
                const grainIntensity = colorModification * 25;
                
                outputData[outputIndex] = Math.max(0, Math.min(255, sourcePixel[0] + grainIntensity));
                outputData[outputIndex + 1] = Math.max(0, Math.min(255, sourcePixel[1] + grainIntensity));
                outputData[outputIndex + 2] = Math.max(0, Math.min(255, sourcePixel[2] + grainIntensity));
                outputData[outputIndex + 3] = 255;
            } else {
                outputData[outputIndex] = sourcePixel[0];
                outputData[outputIndex + 1] = sourcePixel[1];
                outputData[outputIndex + 2] = sourcePixel[2];
                outputData[outputIndex + 3] = 255;
            }
        }
    }
    
    gradientCtx.putImageData(outputImageData, 0, 0);
}

function applyEnhancedFilter() {
    const filterValue = enhancedFilterType.value;
    if (filterValue === 'none') return;
    
    const imageData = gradientCtx.getImageData(0, 0, 400, 533);
    const params = {
        intensity: parseInt(enhancedIntensity.value),
        opacity: parseInt(enhancedOpacity.value),
        scale: parseInt(enhancedScale.value),
        detail: 50, // Default value
        organic: 20, // Default value
        direction: 0 // Default value
    };
    
    switch (filterValue) {
        case 'subtleGrain':
            subtleGrainFilter(imageData, params);
            break;
        case 'fabricWeave':
            fabricWeaveFilter(imageData, params);
            break;
        case 'paperTexture':
            paperTextureFilter(imageData, params);
            break;
        case 'crosshatch':
            crosshatchFilter(imageData, params);
            break;
        case 'brushStroke':
            brushStrokeFilter(imageData, params);
            break;
        case 'linen':
            linenFilter(imageData, params);
            break;
        case 'metallic':
            metallicFilter(imageData, params);
            break;
        case 'concrete':
            concreteFilter(imageData, params);
            break;
        case 'velvet':
            velvetFilter(imageData, params);
            break;
        case 'interference':
            interferenceFilter(imageData, params);
            break;
    }
    
    gradientCtx.putImageData(imageData, 0, 0);
}

function interpolateColor(color1, color2, factor) {
    const hex1 = color1.replace('#', '');
    const hex2 = color2.replace('#', '');
    
    const r1 = parseInt(hex1.substr(0, 2), 16);
    const g1 = parseInt(hex1.substr(2, 2), 16);
    const b1 = parseInt(hex1.substr(4, 2), 16);
    
    const r2 = parseInt(hex2.substr(0, 2), 16);
    const g2 = parseInt(hex2.substr(2, 2), 16);
    const b2 = parseInt(hex2.substr(4, 2), 16);
    
    const r = Math.round(r1 + (r2 - r1) * factor);
    const g = Math.round(g1 + (g2 - g1) * factor);
    const b = Math.round(b1 + (b2 - b1) * factor);
    
    return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
}

function interpolateGradient(gradient1, gradient2, factor) {
    const colors = [];
    const maxColors = Math.max(gradient1.colors.length, gradient2.colors.length);
    
    for (let i = 0; i < maxColors; i++) {
        const color1 = gradient1.colors[i] || gradient1.colors[gradient1.colors.length - 1];
        const color2 = gradient2.colors[i] || gradient2.colors[gradient2.colors.length - 1];
        colors.push(interpolateColor(color1, color2, factor));
    }
    
    const stops = [];
    for (let i = 0; i < maxColors; i++) {
        const stop1 = gradient1.stops[i] || gradient1.stops[gradient1.stops.length - 1];
        const stop2 = gradient2.stops[i] || gradient2.stops[gradient2.stops.length - 1];
        stops.push(stop1 + (stop2 - stop1) * factor);
    }
    
    return {
        colors,
        stops,
        name: `Transitioning (${Math.round(factor * 100)}%)`
    };
}

// Mode switching
modeButtons.forEach(button => {
    button.addEventListener('click', () => {
        const mode = button.dataset.mode;
        switchMode(mode);
    });
});

function switchMode(mode) {
    currentMode = mode;
    
    modeButtons.forEach(btn => {
        btn.classList.toggle('active', btn.dataset.mode === mode);
    });
    
    modeContents.forEach(content => {
        content.classList.toggle('active', content.id === `${mode}-mode`);
    });
    
    timeBadge.style.display = mode === 'time' ? 'block' : 'none';
    
    if (mode === 'time') {
        initTimeMode();
    }
}

// Image analysis functions
function handleFileUpload(file) {
    if (file.size > 10 * 1024 * 1024) {
        alert('File too large. Please choose an image under 10MB.');
        return;
    }

    const reader = new FileReader();
    reader.onload = (e) => {
        imagePreview.src = e.target.result;
        currentImage = new Image();
        currentImage.onload = () => {
            previewSection.style.display = 'block';
            imageControls.style.display = 'block';
            analyzeImage();
        };
        currentImage.src = e.target.result;
    };
    reader.readAsDataURL(file);
}

function analyzeImage() {
    if (!currentImage) return;

    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    
    const maxSize = 200;
    const scale = Math.min(maxSize / currentImage.width, maxSize / currentImage.height);
    canvas.width = currentImage.width * scale;
    canvas.height = currentImage.height * scale;
    
    ctx.drawImage(currentImage, 0, 0, canvas.width, canvas.height);
    
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    extractedColors = extractAtmosphericColors(imageData);
    
    generateImageGradient();
}

function extractAtmosphericColors(imageData) {
    const pixels = [];
    const data = imageData.data;
    
    for (let i = 0; i < data.length; i += 16) {
        const r = data[i];
        const g = data[i + 1];
        const b = data[i + 2];
        const alpha = data[i + 3];
        
        if (alpha > 128) {
            pixels.push([r, g, b]);
        }
    }
    
    if (pixels.length === 0) return ['rgb(150, 150, 150)', 'rgb(100, 100, 100)', 'rgb(200, 200, 200)'];
    
    const middleColors = kMeansColors(pixels, 3);
    return middleColors;
}

function kMeansColors(pixels, k) {
    if (pixels.length === 0) return ['rgb(128, 128, 128)'];
    
    let centroids = [];
    for (let i = 0; i < k; i++) {
        const randomPixel = pixels[Math.floor(Math.random() * pixels.length)];
        centroids.push([...randomPixel]);
    }
    
    for (let iter = 0; iter < 20; iter++) {
        const clusters = Array(k).fill().map(() => []);
        
        pixels.forEach(pixel => {
            let minDistance = Infinity;
            let closestCentroid = 0;
            
            centroids.forEach((centroid, index) => {
                const distance = Math.sqrt(
                    Math.pow(pixel[0] - centroid[0], 2) +
                    Math.pow(pixel[1] - centroid[1], 2) +
                    Math.pow(pixel[2] - centroid[2], 2)
                );
                
                if (distance < minDistance) {
                    minDistance = distance;
                    closestCentroid = index;
                }
            });
            
            clusters[closestCentroid].push(pixel);
        });
        
        centroids = centroids.map((centroid, index) => {
            if (clusters[index].length === 0) return centroid;
            
            return [
                Math.round(clusters[index].reduce((sum, pixel) => sum + pixel[0], 0) / clusters[index].length),
                Math.round(clusters[index].reduce((sum, pixel) => sum + pixel[1], 0) / clusters[index].length),
                Math.round(clusters[index].reduce((sum, pixel) => sum + pixel[2], 0) / clusters[index].length)
            ];
        });
    }
    
    return centroids
        .filter(color => color.every(c => c >= 0 && c <= 255))
        .sort((a, b) => getLuminance(b) - getLuminance(a))
        .map(color => `rgb(${color[0]}, ${color[1]}, ${color[2]})`);
}

function generateImageGradient() {
    const atmosphericIntensity = parseFloat(atmosphericSlider.value);
    const colors = [...extractedColors];
    
    const imageWidth = currentImage.width;
    const imageHeight = currentImage.height;
    
    const ellipseWidth = imageWidth * atmosphericIntensity;
    const ellipseHeight = imageHeight * 2;
    
    gradientCtx.clearRect(0, 0, 400, 533);
    
    const grad = gradientCtx.createRadialGradient(
        200, 533, 0,
        200, 533, Math.max(ellipseWidth * 0.5, ellipseHeight * 0.5)
    );
    
    colors.forEach((color, index) => {
        grad.addColorStop(index / (colors.length - 1), color);
    });
    
    gradientCtx.fillStyle = grad;
    gradientCtx.fillRect(0, 0, 400, 533);
    
    // Apply enhanced filter if enabled
    if (enhancedEffectsEnabled) {
        applyEnhancedFilter();
    }
    
    const gradientCSS = `radial-gradient(ellipse ${ellipseWidth}px ${ellipseHeight}px at 50% 100%, ${colors.join(', ')})`;
    
    currentGradientData = {
        type: 'image',
        colors: colors,
        css: gradientCSS
    };
    
    updateResults(colors, gradientCSS);
}

// Time mode functions
function initTimeMode() {
    const currentTime = getCurrentTime();
    timeInput.value = currentTime;
    initPresets();
    updateTimeGradient(currentTime);
}

function createGradientString(gradient) {
    const colorStops = gradient.colors
        .map((color, index) => `${color} ${gradient.stops[index]}%`)
        .join(", ");

    return `radial-gradient(ellipse at 50% 100%, ${colorStops})`;
}

function updateTimeGradient(timeString) {
    const category = getTimeCategory(timeString);
    const gradient = timeGradients[category];
    const formattedTime = formatTime(timeString);
    const gradientCSS = createGradientString(gradient);

    currentGradientData = {
        type: 'time',
        colors: gradient.colors,
        stops: gradient.stops,
        css: gradientCSS,
        name: gradient.name,
        timeString: timeString,
        category: category
    };

    timeDisplay.textContent = `${formattedTime} - ${gradient.name}`;
    timeBadge.textContent = formattedTime;

    // Draw gradient
    gradientCtx.clearRect(0, 0, 400, 533);
    
    const grad = gradientCtx.createRadialGradient(
        200, 533, 0,
        200, 533, Math.max(400, 533)
    );

    gradient.colors.forEach((color, index) => {
        grad.addColorStop(gradient.stops[index] / 100, color);
    });

    gradientCtx.fillStyle = grad;
    gradientCtx.fillRect(0, 0, 400, 533);

    // Apply effects if enabled
    if (effectsEnabled) {
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = 400;
        tempCanvas.height = 533;
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.drawImage(gradientCanvas, 0, 0);
        applyOpticalEffects(tempCanvas, gradient);
    }
    
    // Apply enhanced filter if enabled
    if (enhancedEffectsEnabled) {
        applyEnhancedFilter();
    }

    updateResults(gradient.colors, gradientCSS);
    updatePresetButtons(timeString);
}

function updateResults(colors, gradientCSS) {
    // Update mini color palette
    colorPaletteMini.innerHTML = "";
    colors.forEach((color) => {
        const colorItem = document.createElement("div");
        colorItem.className = "color-swatch-mini";
        colorItem.style.backgroundColor = color;
        colorItem.onclick = () => copyColor(color);
        colorPaletteMini.appendChild(colorItem);
    });

    // Update CSS preview
    cssPreview.textContent = gradientCSS;
    
    // Show info bar and export actions
    gradientInfoBar.style.display = 'block';
    exportActions.style.display = 'block';
}

function updatePresetButtons(selectedTime) {
    const buttons = presetsGrid.querySelectorAll(".preset-btn");
    buttons.forEach((btn) => {
        btn.classList.toggle('active', btn.dataset.time === selectedTime);
    });
}

function initPresets() {
    presetsGrid.innerHTML = '';
    presetTimes.forEach((preset) => {
        const button = document.createElement("button");
        button.className = "preset-btn";
        button.textContent = preset.label;
        button.dataset.time = preset.time;
        button.addEventListener("click", () => {
            if (!isAnimating) {
                timeInput.value = preset.time;
                updateTimeGradient(preset.time);
            }
        });
        presetsGrid.appendChild(button);
    });
}

// Event listeners for image mode
uploadArea.addEventListener('click', () => fileInput.click());

uploadArea.addEventListener('dragover', (e) => {
    e.preventDefault();
    uploadArea.classList.add('dragover');
});

uploadArea.addEventListener('dragleave', () => {
    uploadArea.classList.remove('dragover');
});

uploadArea.addEventListener('drop', (e) => {
    e.preventDefault();
    uploadArea.classList.remove('dragover');
    const file = e.dataTransfer.files[0];
    if (file && file.type.startsWith('image/')) {
        handleFileUpload(file);
    }
});

fileInput.addEventListener('change', (e) => {
    if (e.target.files[0]) {
        handleFileUpload(e.target.files[0]);
    }
});

atmosphericSlider.addEventListener('input', (e) => {
    atmosphericValue.textContent = e.target.value + 'x';
    if (extractedColors.length > 0) {
        generateImageGradient();
    }
});

// Event listeners for time mode
timeInput.addEventListener("change", (e) => {
    if (!isAnimating) {
        updateTimeGradient(e.target.value);
    }
});

currentTimeBtn.addEventListener("click", () => {
    if (!isAnimating) {
        const currentTime = getCurrentTime();
        timeInput.value = currentTime;
        updateTimeGradient(currentTime);
    }
});

// Effects toggle functionality
function toggleEffects() {
    effectsEnabled = !effectsEnabled;
    effectsToggle.classList.toggle('active', effectsEnabled);
    
    if (effectsEnabled) {
        effectsControls.classList.remove('disabled');
    } else {
        effectsControls.classList.add('disabled');
    }
    
    // Re-render current gradient
    if (currentMode === 'time') {
        updateTimeGradient(timeInput.value);
    } else if (currentMode === 'image' && extractedColors.length > 0) {
        generateImageGradient();
    }
}

function toggleEnhancedEffects() {
    enhancedEffectsEnabled = !enhancedEffectsEnabled;
    enhancedEffectsToggle.classList.toggle('active', enhancedEffectsEnabled);
    
    if (enhancedEffectsEnabled) {
        enhancedEffectsControls.classList.remove('disabled');
    } else {
        enhancedEffectsControls.classList.add('disabled');
    }
    
    // Re-render current gradient
    if (currentMode === 'time') {
        updateTimeGradient(timeInput.value);
    } else if (currentMode === 'image' && extractedColors.length > 0) {
        generateImageGradient();
    }
}

effectsToggle.addEventListener("click", toggleEffects);
enhancedEffectsToggle.addEventListener("click", toggleEnhancedEffects);

// Enhanced preset functionality
document.querySelectorAll('.enhanced-preset-btn').forEach(btn => {
    btn.addEventListener('click', () => {
        const presetName = btn.dataset.preset;
        const preset = enhancedPresets[presetName];
        if (preset) {
            if (enhancedIntensity) enhancedIntensity.value = preset.intensity;
            if (enhancedOpacity) enhancedOpacity.value = preset.opacity;
            if (enhancedScale) enhancedScale.value = preset.scale;
            
            // Update display values
            updateEnhancedEffectValues();
            
            // Update active state
            document.querySelectorAll('.enhanced-preset-btn').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
            
            // Re-render gradient
            if (enhancedEffectsEnabled) {
                if (currentMode === 'time') {
                    updateTimeGradient(timeInput.value);
                } else if (currentMode === 'image' && extractedColors.length > 0) {
                    generateImageGradient();
                }
            }
        }
    });
});

// Update effect values function
function updateEffectValues() {
    if (effectIntensityVal && effectIntensity) effectIntensityVal.textContent = effectIntensity.value;
    if (patternScaleVal && patternScale) patternScaleVal.textContent = patternScale.value;
    if (organicVariationVal && organicVariation) organicVariationVal.textContent = organicVariation.value + '%';
    if (grainSizeVal && grainSize) grainSizeVal.textContent = grainSize.value;
}

function updateEnhancedEffectValues() {
    if (enhancedIntensityValue && enhancedIntensity) enhancedIntensityValue.textContent = enhancedIntensity.value;
    if (enhancedOpacityValue && enhancedOpacity) enhancedOpacityValue.textContent = enhancedOpacity.value + '%';
    if (enhancedScaleValue && enhancedScale) enhancedScaleValue.textContent = enhancedScale.value;
}

// Add effect control event listeners
if (effectType) {
    effectType.addEventListener("change", () => {
        if (effectsEnabled && !isAnimating && currentMode === 'time') {
            updateTimeGradient(timeInput.value);
        }
    });
}

if (effectIntensity) {
    effectIntensity.addEventListener("input", () => {
        updateEffectValues();
        if (effectsEnabled && !isAnimating && currentMode === 'time') {
            updateTimeGradient(timeInput.value);
        }
    });
}

if (patternScale) {
    patternScale.addEventListener("input", () => {
        updateEffectValues();
        if (effectsEnabled && !isAnimating && currentMode === 'time') {
            updateTimeGradient(timeInput.value);
        }
    });
}

if (organicVariation) {
    organicVariation.addEventListener("input", () => {
        updateEffectValues();
        if (effectsEnabled && !isAnimating && currentMode === 'time') {
            updateTimeGradient(timeInput.value);
        }
    });
}

if (grainSize) {
    grainSize.addEventListener("input", () => {
        updateEffectValues();
        if (effectsEnabled && !isAnimating && currentMode === 'time') {
            updateTimeGradient(timeInput.value);
        }
    });
}

// Enhanced effects event listeners
if (enhancedFilterType) {
    enhancedFilterType.addEventListener("change", () => {
        if (enhancedEffectsEnabled && !isAnimating) {
            if (currentMode === 'time') {
                updateTimeGradient(timeInput.value);
            } else if (currentMode === 'image' && extractedColors.length > 0) {
                generateImageGradient();
            }
        }
    });
}

[enhancedIntensity, enhancedOpacity, enhancedScale].forEach(slider => {
    if (slider) {
        slider.addEventListener('input', () => {
            updateEnhancedEffectValues();
            if (enhancedEffectsEnabled && !isAnimating) {
                if (currentMode === 'time') {
                    updateTimeGradient(timeInput.value);
                } else if (currentMode === 'image' && extractedColors.length > 0) {
                    generateImageGradient();
                }
            }
        });
    }
});

// Initialize effect values
updateEffectValues();
updateEnhancedEffectValues();

// Animation functionality
function startAnimation() {
    const startTime = document.getElementById('start-time').value;
    const endTime = document.getElementById('end-time').value;
    const duration = parseInt(document.getElementById('duration').value) * 1000;
    
    const startMinutes = timeToMinutes(startTime);
    let endMinutes = timeToMinutes(endTime);
    
    if (endMinutes < startMinutes) {
        endMinutes += 24 * 60;
    }
    
    const totalMinutes = endMinutes - startMinutes;
    const startTimestamp = Date.now();
    
    isAnimating = true;
    playBtn.style.display = 'none';
    stopBtn.style.display = 'block';
    
    animationInterval = setInterval(() => {
        const elapsed = Date.now() - startTimestamp;
        const progress = Math.min(elapsed / duration, 1);
        
        progressBar.style.width = `${progress * 100}%`;
        
        const currentMinutes = startMinutes + (totalMinutes * progress);
        const currentTime = minutesToTime(Math.round(currentMinutes % (24 * 60)));
        
        updateTimeGradient(currentTime);
        timeInput.value = currentTime;
        
        if (progress >= 1) {
            stopAnimation();
        }
    }, 50);
}

function stopAnimation() {
    if (animationInterval) {
        clearInterval(animationInterval);
        animationInterval = null;
    }
    
    isAnimating = false;
    playBtn.style.display = 'block';
    stopBtn.style.display = 'none';
    progressBar.style.width = '0%';
}

function minutesToTime(totalMinutes) {
    const hours = Math.floor(totalMinutes / 60);
    const minutes = totalMinutes % 60;
    return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
}

playBtn.addEventListener("click", startAnimation);
stopBtn.addEventListener("click", stopAnimation);

// Utility functions
function copyColor(color) {
    navigator.clipboard.writeText(color).catch(() => {
        const textArea = document.createElement('textarea');
        textArea.value = color;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
    });
    
    // Visual feedback
    const event = document.createEvent('CustomEvent');
    event.initCustomEvent('colorCopied', true, true, { color });
    document.dispatchEvent(event);
}

function copyCSS() {
    if (!currentGradientData) return;
    
    const cssText = currentGradientData.css;
    navigator.clipboard.writeText(cssText).then(() => {
        const button = document.querySelector('.quick-copy');
        const originalText = button.textContent;
        button.textContent = '✅ Copied!';
        button.classList.add('copied');
        setTimeout(() => {
            button.textContent = originalText;
            button.classList.remove('copied');
        }, 2000);
    }).catch(() => {
        const textArea = document.createElement('textarea');
        textArea.value = cssText;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
    });
}

function downloadFile(content, filename, contentType = 'text/plain') {
    const blob = new Blob([content], { type: contentType });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    link.click();
    URL.revokeObjectURL(url);
}

// Export functions
function exportImage() {
    if (!currentGradientData) {
        alert('Please generate a gradient first!');
        return;
    }

    const canvas = document.createElement('canvas');
    canvas.width = 800;
    canvas.height = 1066;
    const ctx = canvas.getContext('2d');
    
    // Scale the current gradient to export size
    ctx.drawImage(gradientCanvas, 0, 0, 800, 1066);
    
    const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
    const filename = `gradient-${currentGradientData.type}-${timestamp}.png`;
    
    canvas.toBlob((blob) => {
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        link.click();
        URL.revokeObjectURL(url);
    }, 'image/png');
}

function exportSVG() {
    if (!currentGradientData) {
        alert('Please generate a gradient first!');
        return;
    }

    const { colors, stops } = currentGradientData;
    const width = 400;
    const height = 533;
    
    const gradientId = 'export-gradient';
    let svgContent = `<?xml version="1.0" encoding="UTF-8"?>
<svg width="${width}" height="${height}" viewBox="0 0 ${width} ${height}" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <radialGradient id="${gradientId}" cx="50%" cy="100%" r="100%">`;
    
    if (currentGradientData.type === 'time') {
        colors.forEach((color, index) => {
            svgContent += `\n      <stop offset="${stops[index]}%" stop-color="${color}"/>`;
        });
    } else {
        colors.forEach((color, index) => {
            const offset = (index / (colors.length - 1)) * 100;
            svgContent += `\n      <stop offset="${offset}%" stop-color="${color}"/>`;
        });
    }
    
    svgContent += `
    </radialGradient>
  </defs>
  <rect width="100%" height="100%" fill="url(#${gradientId})"/>
</svg>`;
    
    const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
    const filename = `gradient-${currentGradientData.type}-${timestamp}.svg`;
    downloadFile(svgContent, filename, 'image/svg+xml');
}

function exportCSS() {
    if (!currentGradientData) {
        alert('Please generate a gradient first!');
        return;
    }

    const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
    const filename = `gradient-${currentGradientData.type}-${timestamp}.css`;
    
    const cssContent = `/* Gradient exported from Ultimate Gradient Generator */
/* Generated on: ${new Date().toLocaleString()} */
/* Type: ${currentGradientData.type} */
${currentGradientData.name ? `/* Name: ${currentGradientData.name} */` : ''}

.gradient {
  background: ${currentGradientData.css};
}

.gradient-fullscreen {
  width: 100vw;
  height: 100vh;
  background: ${currentGradientData.css};
}`;

    downloadFile(cssContent, filename, 'text/css');
}

function exportJSON() {
    if (!currentGradientData) {
        alert('Please generate a gradient first!');
        return;
    }

    const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
    const filename = `gradient-data-${timestamp}.json`;
    
    const exportData = {
        ...currentGradientData,
        exported: new Date().toISOString()
    };

    downloadFile(JSON.stringify(exportData, null, 2), filename, 'application/json');
}

// Initialize
function init() {
    switchMode('image');
    
    // Set up global analyzeImage function for button
    window.analyzeImage = analyzeImage;
}

init();
    </script>
</body>
</html>
