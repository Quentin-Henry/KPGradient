<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Halftone Gradient Demo</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            color: white;
            display: flex;
            gap: 20px;
        }
        
        .controls {
            width: 250px;
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            height: fit-content;
        }
        
        .control-group {
            margin-bottom: 20px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
            color: #ccc;
        }
        
        .control-group input, select {
            width: 100%;
            padding: 8px;
            border: none;
            border-radius: 4px;
            background: #3a3a3a;
            color: white;
        }
        
        .canvas-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        canvas {
            border: 1px solid #444;
            border-radius: 8px;
            background: white;
        }
        
        .gradient-options {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .gradient-btn {
            padding: 8px 12px;
            background: #4a4a4a;
            border: none;
            border-radius: 4px;
            color: white;
            cursor: pointer;
            font-size: 12px;
        }
        
        .gradient-btn.active {
            background: #0066cc;
        }
        
        .info {
            font-size: 12px;
            color: #888;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="controls">
        <h3>Halftone Controls</h3>
        
        <div class="control-group">
            <label>Grid Size</label>
            <input type="range" id="gridSize" min="2" max="50" value="16" step="1">
            <span id="gridSizeValue">16px</span>
        </div>
        
        <div class="control-group">
            <label>Rotation Angle</label>
            <input type="range" id="rotation" min="0" max="90" value="25" step="1">
            <span id="rotationValue">25°</span>
        </div>
        
        <div class="control-group">
            <label>Min Size</label>
            <input type="range" id="minSize" min="0" max="1" value="0.1" step="0.05">
            <span id="minSizeValue">0.1</span>
        </div>
        
        <div class="control-group">
            <label>Max Size</label>
            <input type="range" id="maxSize" min="0.5" max="2" value="1" step="0.1">
            <span id="maxSizeValue">1.0</span>
        </div>
        
        <div class="control-group">
            <label>Invert Values</label>
            <input type="checkbox" id="invert">
        </div>
        
        <div class="control-group">
            <label>Shape</label>
            <select id="shape">
                <option value="square">Square</option>
                <option value="circle">Circle</option>
                <option value="diamond">Diamond</option>
            </select>
        </div>
        
        <div class="control-group">
            <button id="exportSvg" style="width: 100%; padding: 12px; background: #0066cc; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">
                Export as SVG
            </button>
        </div>
        
        <div class="info">
            Adjust parameters to see how brightness values map to shape sizes in the halftone pattern. Export creates an SVG with transparent background for overlay use.
        </div>
    </div>
    
    <div class="canvas-container">
        <div class="gradient-options">
            <button class="gradient-btn active" data-gradient="linear">Linear</button>
            <button class="gradient-btn" data-gradient="radial">Radial</button>
            <button class="gradient-btn" data-gradient="diagonal">Diagonal</button>
            <button class="gradient-btn" data-gradient="complex">Complex</button>
        </div>
        
        <canvas id="canvas" width="600" height="400"></canvas>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // Control references
        const gridSizeSlider = document.getElementById('gridSize');
        const rotationSlider = document.getElementById('rotation');
        const minSizeSlider = document.getElementById('minSize');
        const maxSizeSlider = document.getElementById('maxSize');
        const invertCheckbox = document.getElementById('invert');
        const shapeSelect = document.getElementById('shape');
        const gradientBtns = document.querySelectorAll('.gradient-btn');
        const exportSvgBtn = document.getElementById('exportSvg');
        
        // Value displays
        const gridSizeValue = document.getElementById('gridSizeValue');
        const rotationValue = document.getElementById('rotationValue');
        const minSizeValue = document.getElementById('minSizeValue');
        const maxSizeValue = document.getElementById('maxSizeValue');
        
        let currentGradient = 'linear';
        
        // Update value displays
        function updateValueDisplays() {
            gridSizeValue.textContent = gridSizeSlider.value + 'px';
            rotationValue.textContent = rotationSlider.value + '°';
            minSizeValue.textContent = parseFloat(minSizeSlider.value).toFixed(2);
            maxSizeValue.textContent = parseFloat(maxSizeSlider.value).toFixed(1);
        }
        
        // Create gradient background
        function createGradient(type) {
            const gradient = ctx.createImageData(canvas.width, canvas.height);
            const data = gradient.data;
            
            for (let y = 0; y < canvas.height; y++) {
                for (let x = 0; x < canvas.width; x++) {
                    const index = (y * canvas.width + x) * 4;
                    let value = 0;
                    
                    switch (type) {
                        case 'linear':
                            value = x / canvas.width;
                            break;
                        case 'radial':
                            const centerX = canvas.width / 2;
                            const centerY = canvas.height / 2;
                            const distance = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);
                            const maxDistance = Math.sqrt(centerX ** 2 + centerY ** 2);
                            value = 1 - (distance / maxDistance);
                            break;
                        case 'diagonal':
                            value = (x + y) / (canvas.width + canvas.height);
                            break;
                        case 'complex':
                            const nx = x / canvas.width;
                            const ny = y / canvas.height;
                            value = (Math.sin(nx * Math.PI * 3) + Math.cos(ny * Math.PI * 2) + 2) / 4;
                            break;
                    }
                    
                    const gray = Math.floor(value * 255);
                    data[index] = gray;     // R
                    data[index + 1] = gray; // G
                    data[index + 2] = gray; // B
                    data[index + 3] = 255;  // A
                }
            }
            
            return gradient;
        }
        
        // Get luminance from RGB
        function getLuminance(r, g, b) {
            return (0.299 * r + 0.587 * g + 0.114 * b) / 255;
        }
        
        // Sample gradient at point
        function sampleGradient(gradientData, x, y) {
            if (x < 0 || x >= canvas.width || y < 0 || y >= canvas.height) return 0;
            
            const index = (Math.floor(y) * canvas.width + Math.floor(x)) * 4;
            const r = gradientData.data[index];
            const g = gradientData.data[index + 1];
            const b = gradientData.data[index + 2];
            
            return getLuminance(r, g, b);
        }
        
        // Draw shape (for canvas rendering)
        function drawShape(x, y, size, shape) {
            ctx.fillStyle = '#333';
            
            switch (shape) {
                case 'square':
                    const half = size / 2;
                    ctx.fillRect(x - half, y - half, size, size);
                    break;
                case 'circle':
                    ctx.beginPath();
                    ctx.arc(x, y, size / 2, 0, Math.PI * 2);
                    ctx.fill();
                    break;
                case 'diamond':
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.rotate(Math.PI / 4);
                    const diamondHalf = size / 2;
                    ctx.fillRect(-diamondHalf, -diamondHalf, size, size);
                    ctx.restore();
                    break;
            }
        }
        
        // Generate SVG path for shape
        function generateShapeSVG(x, y, size, shape) {
            switch (shape) {
                case 'square':
                    const half = size / 2;
                    return `<rect x="${x - half}" y="${y - half}" width="${size}" height="${size}" fill="#333333"/>`;
                
                case 'circle':
                    return `<circle cx="${x}" cy="${y}" r="${size / 2}" fill="#333333"/>`;
                
                case 'diamond':
                    const diamondHalf = size / 2;
                    const points = [
                        [x, y - diamondHalf],
                        [x + diamondHalf, y],
                        [x, y + diamondHalf],
                        [x - diamondHalf, y]
                    ].map(p => p.join(',')).join(' ');
                    return `<polygon points="${points}" fill="#333333"/>`;
                
                default:
                    return '';
            }
        }
        
        // Export as SVG
        function exportSVG() {
            const gridSize = parseInt(gridSizeSlider.value);
            const rotation = parseFloat(rotationSlider.value);
            const minSize = parseFloat(minSizeSlider.value);
            const maxSize = parseFloat(maxSizeSlider.value);
            const invert = invertCheckbox.checked;
            const shape = shapeSelect.value;
            
            // Create gradient data for sampling
            const gradientData = createGradient(currentGradient);
            
            // Start SVG
            let svgContent = `<?xml version="1.0" encoding="UTF-8"?>
<svg width="${canvas.width}" height="${canvas.height}" viewBox="0 0 ${canvas.width} ${canvas.height}" xmlns="http://www.w3.org/2000/svg">
<g transform="rotate(${rotation} ${canvas.width/2} ${canvas.height/2})">`;
            
            // Generate shapes
            const rotationRad = -rotation * Math.PI / 180;
            const cos = Math.cos(rotationRad);
            const sin = Math.sin(rotationRad);
            
            for (let gridY = -gridSize; gridY < canvas.height + gridSize; gridY += gridSize) {
                for (let gridX = -gridSize; gridX < canvas.width + gridSize; gridX += gridSize) {
                    // Transform grid point back to sample from original gradient
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    
                    // Translate to origin
                    const tx = gridX - centerX;
                    const ty = gridY - centerY;
                    
                    // Rotate back
                    const originalX = tx * cos - ty * sin + centerX;
                    const originalY = tx * sin + ty * cos + centerY;
                    
                    // Sample gradient at original position
                    let luminance = sampleGradient(gradientData, originalX, originalY);
                    
                    if (invert) {
                        luminance = 1 - luminance;
                    }
                    
                    // Map luminance to size
                    const size = minSize + (maxSize - minSize) * luminance;
                    const actualSize = size * gridSize;
                    
                    // Only add shapes that are visible
                    if (actualSize > 0.1) {
                        svgContent += generateShapeSVG(gridX, gridY, actualSize, shape);
                    }
                }
            }
            
            svgContent += `</g>
</svg>`;
            
            // Create and download file
            const blob = new Blob([svgContent], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `halftone-${currentGradient}-${rotation}deg-${gridSize}px.svg`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
        }
        
        // Main render function
        function render() {
            const gridSize = parseInt(gridSizeSlider.value);
            const rotation = parseFloat(rotationSlider.value) * Math.PI / 180;
            const minSize = parseFloat(minSizeSlider.value);
            const maxSize = parseFloat(maxSizeSlider.value);
            const invert = invertCheckbox.checked;
            const shape = shapeSelect.value;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Create and sample gradient
            const gradientData = createGradient(currentGradient);
            
            // Set up rotation transform
            ctx.save();
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.rotate(rotation);
            ctx.translate(-canvas.width / 2, -canvas.height / 2);
            
            // Create halftone pattern
            const cos = Math.cos(-rotation);
            const sin = Math.sin(-rotation);
            
            for (let gridY = -gridSize; gridY < canvas.height + gridSize; gridY += gridSize) {
                for (let gridX = -gridSize; gridX < canvas.width + gridSize; gridX += gridSize) {
                    // Transform grid point back to sample from original gradient
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    
                    // Translate to origin
                    const tx = gridX - centerX;
                    const ty = gridY - centerY;
                    
                    // Rotate back
                    const originalX = tx * cos - ty * sin + centerX;
                    const originalY = tx * sin + ty * cos + centerY;
                    
                    // Sample gradient at original position
                    let luminance = sampleGradient(gradientData, originalX, originalY);
                    
                    if (invert) {
                        luminance = 1 - luminance;
                    }
                    
                    // Map luminance to size
                    const size = minSize + (maxSize - minSize) * luminance;
                    const actualSize = size * gridSize;
                    
                    // Draw shape at grid position
                    drawShape(gridX, gridY, actualSize, shape);
                }
            }
            
            ctx.restore();
            
            updateValueDisplays();
        }
        
        // Event listeners
        gridSizeSlider.addEventListener('input', render);
        rotationSlider.addEventListener('input', render);
        minSizeSlider.addEventListener('input', render);
        maxSizeSlider.addEventListener('input', render);
        invertCheckbox.addEventListener('change', render);
        shapeSelect.addEventListener('change', render);
        exportSvgBtn.addEventListener('click', exportSVG);
        
        gradientBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                gradientBtns.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentGradient = btn.dataset.gradient;
                render();
            });
        });
        
        // Initial render
        render();
    </script>
</body>
</html>